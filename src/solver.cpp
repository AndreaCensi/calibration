/*!
		\file solver.cpp
		\author Carlo Masone, Margherita Petrocchi, Lorenzo Rosa
		\brief Estimates odometry and sensor parameters
*/

#include <stdio.h> 
#include <fstream>
#include <stdlib.h>
#include <vector>
#include <math.h>
#include <iostream>

#include <gsl/gsl_blas.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>

#include <options/options.h>
#include <json-c/json.h>
#include <csm/csm_all.h>

#include "aux_functions.h"
#include "solver_options.h"
#include "solver_utils.h"

#define vg(X,Y) 	( gsl_vector_get(X,Y) )
#define vs(X,Y,Z) 	( gsl_vector_set(X,Y,Z) )
#define mg(X,Y,Z) 	( gsl_matrix_get(X,Y,Z) )
#define ms(X,Y,Z,Q) 	( gsl_matrix_set(X,Y,Z,Q) )

using namespace std;

extern void solver_options(solver_params*p, struct option*ops);
double f (const gsl_vector *z, void *params);

/*!
	Solver routine
	\brief This program has been developed to estimate parameters (odometry and sensor) given a list of tuples generated by synchronizer. 
	
	It uses gsl libraries to handle matrix and vectors, as well as minimization and eigenvalues solution.
	
*/
int main(int argc, const char * argv[]) {
	/*!<!--###############		Verify options		################-->*/
	solver_params params;	
	struct option* ops = options_allocate(100);
	solver_options(&params, ops);
	if(!options_parse_args(ops, argc, argv)) {
		options_print_help(ops, stderr);
		return 1;
	}		

	/*!<!--#################		 Read input		##################-->*/
	vector <JO> tuple;
	if (!read_jsonlist(params.input_file, &tuple) ) {
		sm_error("Error opening input files.\n");
		return 2;
	}

/*!<!--####################		FIRST STEP: estimate J21 and J22  	#################-->*/
	double J21, J22;
	gsl_matrix * A 	= gsl_matrix_calloc(2,2);
 	gsl_vector * g 	= gsl_vector_calloc(2);
 	gsl_vector * L_i 	= gsl_vector_alloc(2);
 	double th_i;
	int n = (int) tuple.size();	

	for (int i = 0; i < n; i++)	{
		double T, phi_l, phi_r;
		double sm[3];
		jo_read_double(tuple[i], "T", &T);
		jo_read_double(tuple[i], "phi_l", &phi_l);
		jo_read_double(tuple[i], "phi_r", &phi_r);
		jo_read_double_array (tuple[i], "sm", sm, 3, 0.0);
		vs( L_i, 0,  T*phi_l); 
		vs( L_i, 1,  T*phi_r);
		gsl_blas_dger  (1, L_i, L_i, A); // A = A + L_i'*L_i;  A symmetric 
		gsl_blas_daxpy (sm[2], L_i, g);  // g = g + L_i'*y_i;  sm :{x , y, theta}
	}
	gsl_vector_free(L_i);
	
	// Verify that A isn't singular
	double cond = cond_number(A);
 	if ( cond > 50 ) {
 		sm_error("Matrix A is almost singular. Not very exciting data!\n");
		return 3;
 	}
	
	// Ay = g --> y = inv(A)g; A square matrix;
	gsl_vector * y = gsl_vector_calloc(2);
	if (!solve_square_linear(A, g, y)) {
		sm_error("Cannot solve Ay=g. Invalid arguments\n");
		return 4;
	}
	J21 = vg(y, 0); J22 = vg(y, 1);
 	if ( gsl_isnan(J21) || gsl_isnan(J22) ) {
 		sm_error("Could not find first two parameters J21, J22");
		return 5;
 	}
	//cout << "J21,J22: " << J21 << ", " << J22 << endl;
	gsl_vector_free(y);	

/*!<!--############## 		SECOND STEP: estimate the remaining parameters  		########-->*/	
	// Build M, M2
	gsl_matrix * M    	 = gsl_matrix_calloc(5,5);	
	gsl_matrix * M2   	 = gsl_matrix_calloc(6,6);
	gsl_matrix * L_k  	 = gsl_matrix_calloc(2,5);
	gsl_matrix * L_2k 	 = gsl_matrix_calloc(2,6);	
	double c, cx, cy, cx1, cx2, cy1, cy2, t1, t2;	
	double o_theta, T, phi_l, phi_r, w0;
	double sm[3];

	for (int k = 0; k < n; k++) {
		jo_read_double(tuple[k], "T", &T);
		jo_read_double(tuple[k], "phi_l", &phi_l);
		jo_read_double(tuple[k], "phi_r", &phi_r);
		jo_read_double_array (tuple[k], "sm", sm, 3, 0.0);
				
		o_theta  = T * (J21*phi_l + J22*phi_r);
		w0 = o_theta / T;
				
		if ( fabs(o_theta) > 1e-12 ) {
			t1 = (   sin(o_theta)   / (o_theta) );
			t2 = ( (1-cos(o_theta)) / (o_theta) );	
		}
		else {
			t1 = 1;
			t2 = 0;
		}		
		cx1 = 0.5 * T * (-J21 * phi_l) * t1;
		cx2 = 0.5 * T * (+J22 * phi_r) * t1;
		cy1 = 0.5 * T * (-J21 * phi_l) * t2;
		cy2 = 0.5 * T * (+J22 * phi_r) * t2;
		if ( (params.mode == 0)||(params.mode == 1) ) {
			cx = cx1 + cx2;
			cy = cy1 + cy2; 			
			double array[] = { 
				-cx, 1-cos(o_theta),   sin(o_theta), sm[0], -sm[1],
				-cy,  -sin(o_theta), 1-cos(o_theta), sm[1],  sm[0]
			};
			gsl_matrix_view tmp = gsl_matrix_view_array(array, 2, 5);
			L_k = &tmp.matrix;		
			// M = M + L_k' * L_k; M is symmetric
			gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, L_k, L_k, 1, M);
		}
		else {
			double array2[] = { 
				-cx1, -cx2, 1-cos(o_theta), 	sin(o_theta), sm[0], -sm[1],
				-cy1, -cy2,  -sin(o_theta), 1-cos(o_theta), sm[1],  sm[0]
			};
			gsl_matrix_view tmp = gsl_matrix_view_array(array2, 2, 6);
			L_2k = &tmp.matrix;		
			// M2 = M2 + L_2k' * L_2k; M2 is symmetric
			gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, L_2k, L_2k, 1, M2); 
		}
	}
	
	double est_b, est_d_l, est_d_r, laser_x, laser_y, laser_th;
	gsl_vector * x;
	switch (params.mode)
	{
	case 0:	/*!<!--######### mode 0: minimize in closed form, using M ########-->*/
		{
			x = full_calibration_min(M);
			
			est_b = vg(x, 0);
			est_d_l = 2*(-est_b * J21);
			est_d_r  = 2*(est_b * J22);
			laser_x = vg(x, 1);
			laser_y = vg(x, 2);
			laser_th = atan2(vg(x, 4), vg(x, 3));
			break;
		}
	case 1:	/*!<!--####  mode 1: start at the minimum eigenvalue, find numerical solution using M  ####-->*/
		{
			x = numeric_calibration(M);
				
			est_b = vg(x, 0);
			est_d_l = 2*(-est_b * J21);
			est_d_r  = 2*(est_b * J22);
			laser_x = vg(x, 1);
			laser_y = vg(x, 2);
			laser_th = atan2(vg(x, 4), vg(x, 3));
			break;
		}	
	case 2:	/*!<!--####  mode 2: start at the minimum eigenvalue, find numerical solution using M2 ####-->*/
		{
			x = numeric_calibration(M2);

			est_b = (vg(x, 0) + vg(x, 1))/2;
			est_d_l = 2*(-est_b * J21);
			est_d_r  = 2*(est_b * J22);
			laser_x = vg(x, 2);
			laser_y = vg(x, 3);
			laser_th = atan2(vg(x, 5), vg(x, 4));
			break;
		}
	default:
		break;
	}

/*!<!--###################		  TEST  		####################-->*/
// 	gsl_matrix * M3   	 = gsl_matrix_calloc(6,6);
// 	gsl_matrix * L_3k 	 = gsl_matrix_calloc(2,6);	
// 	double dx1, dx2, dy1, dy2;	
// 	double J11, J12;
// 	
// 	for (int k = 0; k < n; k++) {
// 		jo_read_double(tuple[k], "T", &T);
// 		jo_read_double(tuple[k], "phi_l", &phi_l);
// 		jo_read_double(tuple[k], "phi_r", &phi_r);
// 		jo_read_double_array (tuple[k], "sm", sm, 3, 0.0);
// 				
// 		o_theta  = sm[2];
// 		w0 = o_theta / T;
// 				
// 		if ( fabs(o_theta) > 1e-12 ) {
// 			t1 = (   sin(o_theta)   / (o_theta) );
// 			t2 = ( (1-cos(o_theta)) / (o_theta) );	
// 		}
// 		else {
// 			t1 = 1;
// 			t2 = 0;
// 		}		
// 		dx1 = T * ( phi_l) * t1;
// 		dx2 = T * ( phi_r) * t1;
// 		dy1 = T * ( phi_l) * t2;
// 		dy2 = T * ( phi_r) * t2;
// 		double array3[] = { 
// 			-dx1, -dx2, 1-cos(o_theta), 	sin(o_theta), sm[0], -sm[1],
// 			-dy1, -dy2,  -sin(o_theta), 1-cos(o_theta), sm[1],  sm[0]
// 		};
// 		gsl_matrix_view tmp = gsl_matrix_view_array(array3, 2, 6);
// 		L_3k = &tmp.matrix;		
// 		gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, L_3k, L_3k, 1, M3); 
// 		
// 	}
// 	gsl_vector * x3;	
// 	x3 = numeric_calibration(M3);
// 	J11 = vg(x3,0);
// 	J12 = vg(x3,1);
// 	cout << "J11,J12: " << J11 << ", " << J12 << endl;
// 	double axle2 = 2*((J11+J12)/(J22-J21));
// 	cout << " new d_l =  " << J11*4 << endl;
// 	cout << " new d_r =  " << J12*4 << endl;
// 	cout << "TEST\n";
// 	cout << " axle  "	<< axle2 << endl;
// 	cout << " l_diam  "  	<< 2*J11 - J21*axle2  << endl;
// 	cout << " r_diam  "  	<< 2*J12 + J22*axle2   << endl;
// 	cout << " l_x  "  	<< vg(x3,2) << endl;
// 	cout << " l_y  "  	<< vg(x3,3) << endl;
// 	cout << " l_th  "  	<< atan2(vg(x3, 5), vg(x3, 4)) << endl;

/*!<!--###################		  Output  		####################-->*/
	// Build json object
	struct json_object *new_obj;
	new_obj = json_object_new_object();		
	
	double est_E_d 	= est_d_r / est_d_l; 
	double est_E_b 	= est_b / 0.09;
	json_object_object_add(new_obj, "axle", json_object_new_double(est_b) );
	json_object_object_add(new_obj, "l_diam", json_object_new_double(est_d_l) );
	json_object_object_add(new_obj, "r_diam", json_object_new_double(est_d_r) );
	json_object_object_add(new_obj, "l_x", json_object_new_double(laser_x) );
	json_object_object_add(new_obj, "l_y", json_object_new_double(laser_y) );
	json_object_object_add(new_obj, "l_theta", json_object_new_double(laser_th) );
	json_object_object_add(new_obj, "E_d", json_object_new_double(est_E_d) );
	json_object_object_add(new_obj, "E_b", json_object_new_double(est_E_b) );
		
	// Write json object to file
	FILE * output;
	if(!strcmp(params.output_file, "stdout")) { output = stdout;}
	else {output = fopen(params.output_file, "w");}
	fprintf(output, "%s\n", json_object_to_json_string(new_obj) );
	fclose(output);
	return 0;
}


